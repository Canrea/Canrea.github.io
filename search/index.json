[{"content":" AOP全称【Aspect Oriented Programming】意为面向切面编程，通过预编译和运行期间通过动态代理来实现程序功能统一维护的技术。AOP思想是OOP【面向对象】的延续，在OOP中以类【class】作为基本单元, 而 AOP中的基本单元是 Aspect【切面】，AOP是软件行业的热点，也是Spring框架中的一个重要内容。\n什么是AOP 在大多数的业务中都需要验证用户是否登录才可以访问接口内容，如果没有登录或没有权限就会做出对应提示，比如下方的添加用户和修改用户的功能：\n添加用户流程\n修改用户流程\n从以上流程可以看出，判断权限和记录日志在方法中都需要调用，如果每个流程中都加入判断权限和记录日志的代码有两个弊端：\n每个业务代码中都需要调用相同的权限判断功能比较重复，比较冗余 业务代码中调用非业务功能，增加耦合，污染业务流程 由此AOP思想就出现了，理想的架构就是将权限判断、记录日志这些共用功能抽离到一个切片中，等到需要时再织入对象中去，从而改变其原有的行为。\nAOP其实只是OOP的补充而已。OOP从横向上区分出一个个的类来，而AOP则从纵向上向对象中加入特定的代码。有了AOP，OOP变得立体了。从技术上来说，AOP基本上是通过代理模式实现。\nAOP体系 AOP术语 通知/增强【advice】 就是增强的功能，比如我们的程序中需要添加日志，事务等功能，我们当然需要将代码写好，封装到中，我们写好的这个方法就是通知，也可以称为增强，通知分为前置通知，后置通知，环绕通知，异常通知等，说明加在连接点的什么位置，什么时候调用\n连接点【Join Point】 可以增强的功能，比如添加、修改、删除等方法都可以被增强。\n切点【Pointcut】 实际上增强的方法，如上实际增强添加、删除功能，这个添加、删除就是切点。也称为切入点。需要使用表达式配置\n切面 【Aspect】 切点、增强所在的那个类叫切面，这些代码需要编写出来，这个配置的类就是切面\n引入【introduction】 允许我们向现有的类添加新方法属性。这不就是把切面（也就是新方法属性：通知定义的）用到目标类中吗\n目标对象【Target】 引入中所提到的目标类，也就是要被通知的对象，也就是真正的业务逻辑，他可以在毫不知情的情况下，被咱们织入切面。而自己专注于业务本身的逻辑。\n代理【proxy】 AOP通过代理模式实现增强，会创建出来一个代理对象，融合了目标对象和增强，执行时使用的是这个新的代理对象。在 Spring AOP 中, 一个 AOP 代理是一个 JDK 动态代理对象或 CGLIB 代理对象\n织入【weaving】 把切面应用到目标对象来创建新的代理对象的过程。根据不同的实现技术, AOP织入有三种方式:\n编译器织入：这要求有特殊的Java编译器 类装载期织入：这需要有特殊的类装载器 动态代理织入：在运行期为目标类添加增强生成代理类的方式 Spring 采用动态代理织入, 而AspectJ采用编译器织入和类装载期织入\n实现 以用户模块为例，有添加、修改、删除、查询方法，对其中方法按照一定规则增强\n基本实现 pom依赖 Spring中要使用AOP需要引入aspectjweaver依赖，如果是SpringBoot引入spring-boot-starter-aop依赖，就已经包含了aspectjweaver。\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-aop\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 接口和实现类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // 接口 public interface IUserService { List\u0026lt;String\u0026gt; list(); int add(); int upodate(); int delete(); } // 实现类 @Service @Slf4j public class UserServiceImpl implements IUserService { @Override public List\u0026lt;String\u0026gt; list() { log.info(\u0026#34;查询用户列表\u0026#34;); return Arrays.asList(\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;); } @Override public int add() { log.info(\u0026#34;添加用户\u0026#34;); return 0; } @Override public int upodate() { log.info(\u0026#34;修改用户\u0026#34;); return 0; } @Override public int delete() { log.info(\u0026#34;删除用户\u0026#34;); return 0; } } 增强 先提供一个权限校验增强和一个日志记录增强，会使用一下几个注解：\n@Aspect：标明类是一个切面类，里边写增强的方法和配置切入点 @Before：前置通知，执行方法前执行 @After：后置通知，执行方法后，返回退出前执行 @AfterReturning：后置增强，方法正常退出时执行 @AfterThrowing：异常抛出增强，抛出异常时执行 @Around：环绕增强，方法前后都执行 权限校验：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // @Aspect表示这个类是一个切面类 @Aspect @Component @Slf4j public class PremissionAdvice { /** * 权限校验：需要在进入业务之前运行，使用前置通知 */ @Before(\u0026#34;execution(* com.stt.service.IUserService.add()) || \u0026#34; + \u0026#34;execution(* com.stt.service.IUserService.upodate()) || \u0026#34; + \u0026#34;execution(* com.stt.service.IUserService.delete())\u0026#34;) public void checkPremission() { log.info(\u0026#34;权限校验......\u0026#34;); } } 日志记录：\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Aspect @Component @Slf4j public class LogAdvice { /** * 添加日志，日志在执行完业务之后添加，使用后置通知 */ @After(\u0026#34;execution(* com.stt.service.IUserService.*(..))\u0026#34;) public void insertLog() { log.info(\u0026#34;添加日志......\u0026#34;); } } 测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @SpringBootApplication public class AOPApplication { public static void main(String[] args) { ConfigurableApplicationContext context = SpringApplication.run(AOPApplication.class); // 获取Bean IUserService userService = context.getBean(IUserService.class); // 调用方法 userService.add(); userService.upodate(); userService.delete(); userService.list(); } } 环绕通知 环绕通知会在方法执行前后分别调用，比如要计算一个方法执行耗时就可以使用环绕通知\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @Aspect @Component @Slf4j public class ExecuteTimeAdvice { /** * 获取执行时间，在执行之前 * @return */ @Around(\u0026#34;execution(* com.stt.service.IUserService.*(..))\u0026#34;) public Object getTimelong(ProceedingJoinPoint joinPoint) { Object result = null; long startTime = System.currentTimeMillis(); // 前置业务代码 log.info(\u0026#34;执行前时间:{}\u0026#34;,startTime); try { // 执行目标方法 result = joinPoint.proceed(); } catch (Throwable e) { e.printStackTrace(); } // 后置业务执行代码 long endTime = System.currentTimeMillis(); log.info(\u0026#34;执行耗时:{}毫秒\u0026#34;,endTime - startTime); return result; } } 切点表达式 上边写的**execution(* com.stt.service.IUserService.*(..))**就是切点表达式，AspectJ ⽀持三种通配符：\n***** ：匹配任意字符，只匹配⼀个元素（包，类，或⽅法，⽅法参数） .. ：匹配任意字符，可以匹配多个元素 ，在表示类时，必须和 * 联合使⽤。 + ：表示按照类型匹配指定类的所有类，必须跟在类名后⾯，如 com.stt.service.IUserService+，表示继承该类的所有子类包括本身 切点表达式由切点函数组成，其中 execution() 是最常⽤的切点函数，⽤来匹配⽅法，语法为：\nexecution(\u0026lt;修饰符\u0026gt;\u0026lt;返回类型\u0026gt;\u0026lt;包.类.⽅法(参数)\u0026gt;\u0026lt;异常\u0026gt;)\n修饰符：一般省略\npublic：公共方法 *：任意方法 返回类型：\nvoid：无返回类型 数据类型，如String、int等等 *：任意类型 包：\ncom.stt.service：固定包 com.stt.*.service：com.stt包下任意包中的service子包 com.stt..：com.stt下的所有子包，包括自己 类：\nIUserService：指定类 *Impl：以Impl结尾的类 User*：以User开头的类 *：任意 方法名：不可省略\naddUser：固定方法 add*：以add开头的方法 *User：以User结尾的方法 *：任意方法 参数：\n()：无参 (数据类型)：指定一个数据类型 (数据类型,数据类型)：指定两个数据类型，其他以此类推 (..)：任意参数 throws：异常类型，一般省略不写\n表达式示例 execution(* com.stt.demo.User.*(..)) ：匹配 User 类⾥的所有⽅法。 execution(* com.stt.demo.User+.*(..)) ：匹配该类的⼦类包括该类的所有⽅法。 execution(* com.stt..(..)) ：匹配 com.stt 包下的所有类的所有⽅法。 execution(* com.stt...(..)) ：匹配 com.stt 包下、⼦孙包下所有类的所有⽅法。 execution(* addUser(String, int)) ：匹配 addUser ⽅法，且第⼀个参数类型是 String，第⼆个参数类型是 int。 其他切点表达式 arg()：限定连接点方法参数 @args()：通过连接点方法参数上的注解进行限定 execution()：用于匹配是连接点的执行方法 this() ：限制连接点匹配 OP Bean 用为指定的类型 target：目标对象（即被代理对象） @target()：限制目标对象的配置了指定的注解 within：限制连接点匹配指定的类型 @within()：限定连接点带有匹配注解类型 @annotation()：限定带有指定注解的连接点 当然表达式之间可以通过**||**【或者】或者 **\u0026amp;\u0026amp;【并且】**连接，所有的表达式可通过官网查看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 匹配指定包中的所有的方法, 但不包括子包 within(com.stt.service.*) // 匹配指定包中的所有的方法, 包括子包 within(com.stt.service..*) // 匹配当前包中的指定类中的方法 within(UserService) // 匹配一个接口的所有实现类中的实现的方法 within(UserDao+) // 匹配以指定名字结尾的 Bean 中的所有方法 bean(*Service) // 匹配以 Service 或 ServiceImpl 结尾的 bean bean(*Service || *ServiceImpl) // 匹配名字以 Service 开头, 并且在包 com.stt.service 中的 bean bean(*Service) \u0026amp;\u0026amp; within(com.stt.service.*) 单独定义切点 切点支持单独配置，之后引用到需要该切点的增强\n1 2 3 4 5 6 7 8 9 // 定义切点 @Pointcut(\u0026#34;execution(* com.stt.service.IUserService.*(..))\u0026#34;) public void afterLog(){} // 使用切点到增强上 @After(\u0026#34;afterLog()\u0026#34;) public void insertLog() { log.info(\u0026#34;添加日志......\u0026#34;); } Spring AOP原理 AOP的实现方式其实是代理模式，代理模式是给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用，代理模式分为静态代理和动态代理。\n静态代理：是由程序员创建或特定工具自动生成源代码，再对其编译。在程序运行之前，代理类.class文件就已经被创建了。 动态代理：在程序运行时通过反射机制动态创建。 Spring AOP的原理是构建在动态代理基础上，Spring对AOP的支持局限于方法级别。Spring AOP 支持 JDK Proxy 和 CGLIB 方式实现动态代理。\n默认情况下，实现了接口的类，使用 AOP 会基于 JDK ⽣成代理类； 没有实现接⼝的类，会基于 CGLIB ⽣成代理类。 静态代理 接口\n1 2 3 public interface IStaticProxyService { void staticProxyMethod(); } 实现类\n1 2 3 4 5 6 7 8 @Slf4j @Service public class StaticProxyServiceImpl implements IStaticProxyService { @Override public void staticProxyMethod() { log.info(\u0026#34;静态代理对象原对象方法......\u0026#34;); } } 代理类：代理类将实现类依赖进来，并实现接口，重写方法在实现自己逻辑的同时调用实现类方法以此实现代理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Service @Slf4j public class StaticProxyServiceProxy implements IStaticProxyService { private final IStaticProxyService staticProxyServiceImpl; public StaticProxyServiceProxy(IStaticProxyService staticProxyServiceImpl) { this.staticProxyServiceImpl = staticProxyServiceImpl; } @Override public void staticProxyMethod() { log.info(\u0026#34;静态代理对象方法......\u0026#34;); // 调用原对象方法 staticProxyServiceImpl.staticProxyMethod(); } } 小结：\n优点：可以做到在符合开闭原则的情况下对目标对象进行功能扩展。 缺点：需要为每一个服务都得创建代理类，工作量太大，不易管理。同时接口一旦发生改变，代理类也得相应修改。 JDK动态代理 不需要生成实现接口，使用JDK的API在内存中构建代理对象\n接口\n1 2 3 public interface IJDKProxyService { void jdkProxyMethod(); } 实现类\n1 2 3 4 5 6 7 @Slf4j public class JDKProxyServiceImpl implements IJDKProxyService { @Override public void jdkProxyMethod() { log.info(\u0026#34;JDK动态代理接口方法......\u0026#34;); } } 代理类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Slf4j @Service public class JDKProxyServiceProxy implements InvocationHandler { private final Object target; public JDKProxyServiceProxy(Object target) { this.target = target; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { Object result = null; log.info(\u0026#34;JDK动态代理......\u0026#34;); // 调用被代理对象方法 result = method.invoke(target,args); return result; } } 测试\n1 2 3 4 5 6 7 8 9 10 //被代理对象 JDKProxyServiceImpl jdkProxyService = new JDKProxyServiceImpl(); //代理对象 JDKProxyServiceProxy serviceProxy = new JDKProxyServiceProxy(jdkProxyService); //获取类加载器 ClassLoader classLoader = jdkProxyService.getClass().getClassLoader(); //获取该类的接口 Class\u0026lt;?\u0026gt;[] interfaces = jdkProxyService.getClass().getInterfaces(); IJDKProxyService ijdkProxyService = (IJDKProxyService)Proxy.newProxyInstance(classLoader, interfaces, serviceProxy); ijdkProxyService.jdkProxyMethod(); 小结 实现InvocationHandler接口重写invoke方法 创建代理对象使用Proxy类的newProxyInstance方法，传入实现类类加载器，接口和代理类的对象 CGLB动态代理 接口\n1 2 3 public interface ICGLIBProxyService { void cglIbMethod(); } 实现类\n1 2 3 4 5 6 7 @Slf4j public class CGLIBProxyServiceImpl implements ICGLIBProxyService { @Override public void cglIbMethod() { log.info(\u0026#34;CGLIB代理实现类方法......\u0026#34;); } } 代理类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @Slf4j public class CGLIBProxyInterceptor implements MethodInterceptor { //被代理对象 private Object target; public CGLIBProxyInterceptor(Object target){ this.target = target; } @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable { log.info(\u0026#34;CGLIB代理方法......\u0026#34;); //通过cglib的代理⽅法调⽤ Object retVal = proxy.invoke(target, args); return retVal; } } 测试\n1 2 3 4 5 6 7 // 创建实现类对象 ICGLIBProxyService target= new CGLIBProxyServiceImpl(); // 构建代理对象 ICGLIBProxyService proxy= (ICGLIBProxyService) Enhancer.create(target.getClass(), new CGLIBProxyInterceptor(target)); proxy.cglIbMethod(); JDK 和 CGLIB 实现的区别 JDK实现：要求被代理类必须实现接⼝，之后是通过 InvocationHandler 及 Proxy，在运⾏时动态的在内存中⽣成了代理类对象，该代理对象是通过实现同样的接⼝实现（类似静态代理接⼝实现的⽅式），只是该代理类是在运⾏期时，动态的织⼊统⼀的业务逻辑字节码来完成。 CGLIB实现：被代理类可以不实现接⼝，是通过继承被代理类，在运⾏时动态的⽣成代理类对象 (三方框架，一般性能有优势)。 \u0026ndash;来自B站[石添的编程哲学]\n","date":"2024-11-15T11:18:24+08:00","permalink":"https://Canrea.github.io/p/spring-aop/","title":"Spring AOP"},{"content":" IOC容器 Spring的IOC容器用来创建、存储、销毁对象并维护对象之间的关系，IOC容器也被称为【Bean容器】。\nIOC的概念 IOC全称【Inversion of Control】，意为控制反转，有的地方称为IOC容器，它是一项对象生成、获取和管理的技术，Java作为一门面向对象的语言，对象的管理至关重要。在传统的java编程中，对象一般通过new构建，二spring通过描述构建对象。\n项目中会有各式各样的对象，这些对象也不是独立存在互不相关的，spring提供了依赖注入【Dependency Injection，DI】来管理各个对象之间的关系。\n常见的关系有：依赖、关联、聚合、组合、继承、实现。\nIOC容器介绍 spring通过工厂创建对象，涉及到的接口和类非常多，其中我们经常打交道的有：\nBeanFactory：定义一系列获取bean的方法，根据不同参数，条件获取Bean，是整个IOC容器体系的根接口。 ApplicationContext：在BeanFactory基础上扩展了事件发布、资源加载、环境参数、国际化消息等功能。 ClassPathXmlApplicationContext：从类路径上读取spring声明文件来创建Bean。 FileSystemXmlApplicationContext：从文件中的spring声明文件来创建Bean。 AnnotationConfigApplicationContext：通过注解来创建Bean，需要指定要识别的包名，会识别通过诸如@Configuration、@Component、@Service、@Bean等描述的类。 ClassPathXmlApplicationContext实践 通过最原始的xml文件管理Bean，需要使用ClassPathXmlApplicationContext容器。\n数据源对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package top.lime.entity; public class User { private Long id; private String name; private Integer age; public User() { } public User(Long id, String name, Integer age) { this.id = id; this.name = name; this.age = age; } public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } xml配置 在resources目录下创建springContext.xml配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!-- spring描述Bean --\u0026gt; \u0026lt;!-- id属性是唯一的，不能重复 --\u0026gt; \u0026lt;bean id=\u0026#34;user1\u0026#34; class=\u0026#34;top.lime.entity.User\u0026#34;\u0026gt; \u0026lt;!-- 指定具体的属性数据 --\u0026gt; \u0026lt;!-- property是通过set方法注入的,需要实体类实现set方法 --\u0026gt; \u0026lt;property name=\u0026#34;id\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;zhangsan\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;18\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;user2\u0026#34; class=\u0026#34;top.lime.entity.User\u0026#34;\u0026gt; \u0026lt;!-- 指定具体的属性数据 --\u0026gt; \u0026lt;!-- constructor-arg是通过构造方法注入的，需要实体类实现了构造方法 --\u0026gt; \u0026lt;constructor-arg name=\u0026#34;id\u0026#34; value=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;name\u0026#34; value=\u0026#34;lisi\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;age\u0026#34; value=\u0026#34;24\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 获取Bean对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @SpringBootApplication public class App { public static void main(String[] args) { //SpringApplication.run(App.class, args); //读取springContext.xml文件获取容器，并通过容器获取Bean ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\u0026#34;springContext.xml\u0026#34;); //获取Bean，getBean()里面可以填Bean的id，也可填Bean的名字，对应xml里面Bean标签的id和name属性 //默认返回的是Object类型，可以强转回原来的类型 User user1 = (User) applicationContext.getBean(\u0026#34;user1\u0026#34;); //不想强转可以通过类型来获取Bean，如果有多个同类型的bean还要额外指定名字 User user2 = applicationContext.getBean(\u0026#34;user2\u0026#34;，User.class); //打印结果 System.out.println(user1); System.out.println(user2); } } FileSystemXmlApplicationContext实践 使用FileSystemXmlApplicationContext的话参数中填写文件路径，其余相同\n获取Bean对象 1 2 3 4 5 6 7 8 9 @SpringBootApplication public class App { public static void main(String[] args) { // 从文件系统获取,传入springContext.xml文件的路径，获取Bean FileSystemXmlApplicationContext applicationContext = new FileSystemXmlApplicationContext(\u0026#34;D:\\\\JavaWeb\\\\porject\\\\springContext.xml\u0026#34;); User user2 = applicationContext.getBean(\u0026#34;user2\u0026#34;, User.class); System.out.println(user2); } } AnnotationConfigApplicationContext实践 此处介绍两种创建Bean方式，一种是在AnnotationConfigApplicationContext的构造方法中传入包名，另一种是在构造方法中传入配置类。\n通过传入包名 在需要创建的Bean上通过@Component或者@Configuration等注解声明bean，相当于bean标签，通过@Value注解注入值。\n数据源对象 这里通过引入的lombok依赖，在类上加注解，实现在编译时生成get/set和构造方法的代码。\n1 2 3 4 5 6 7 8 9 10 11 12 @Data //生成get/set方法 @AllArgsConstructor //生成全参构造函数 @NoArgsConstructor //生成空参构造函数 @Component //通过注解创建对象，spring启动时扫描到有该注解的类，会当作一个Bean加载到IOC容器中 public class Book { @Value(\u0026#34;13\u0026#34;)\t//通过@Value注入参数 private Long id; @Value(\u0026#34;西游记\u0026#34;) private String bookName; @Value(\u0026#34;zhangsan\u0026#34;) private String author; } 获取Bean对象 1 2 3 4 5 6 7 8 9 10 11 12 public class App { public static void main(String[] args) { //通过注解获取Bean //通过包名扫描 比如：top.lime 就会扫描该包下所有的类和子包下的所有类 AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(\u0026#34;top.lime\u0026#34;); //获取Bean name默认的是首字母小写的类名 Book book1 = applicationContext.getBean(\u0026#34;book\u0026#34;); Book book2 = applicationContext.getBean(Book.class); System.out.println(book1); System.out.println(book2); } } 通过注解扫描包 在主类上添加@ComponentScan包扫描注解，注意：该注解会扫描述的类所在包和其子包的注解\n1 2 3 4 5 6 7 8 9 @ComponentScan(value = \u0026#34;top.lime\u0026#34;) //扫描top.lime包下的所有与@Component相关的注解 public class App { public static void main(String[] args) { //通过包扫描注解获取Bean AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(App.class); Book book = applicationContext.getBean(\u0026#34;book\u0026#34;, Book.class); System.out.println(book); } } 通过@Bean注解创建Bean 通过Bean注解创建对象的话，首先需要将User类中的@Value注解取消掉，否则Bean注入的值是Value注解注入的。\n数据源对象 1 2 3 4 5 6 @Data public class Car { private Long id; private String carName; private String brand; } 创建配置类 在配置类中生成Bean并注入IOC容器\n@Configuration：该注解使用在类上，标记该类为一个配置类，用@Component、@Service都可以，只是@Configuration注解更利于理解，更规范。目的就是项目启动时可以识别该类，并且加载该类到IOC容器中。因为该类中有Bean的创建，所以需要加载它！\n@Bean：该注解可以使用在方法和注解上，一般都使用在方法上，表示被描述的方法会返回一个Bean，方法内室创建这个Bean的过程，BeanName默认是方法名，可以通过Bean注解的value属性或name属性自定义BeanName\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //表示CarConfig是一个配置类,他是在@Component的基础上衍生出来的 @Configuration public class CarConfig { //创建Bean,Bean的名字默认是方法名 @Bean //如果需要指定名字则 @Bean(name=\u0026#34;car1\u0026#34;) public Car myCar() { Car car = new Car(); car.setId(10L); car.setCarName(\u0026#34;bird\u0026#34;); car.setBrand(\u0026#34;bbb\u0026#34;); //返回对象,交给IOC管理 return car; } } 获取Bean对象 1 2 3 4 5 6 7 8 public class App { public static void main(String[] args) { //通过@Bean注解创建Bean，并获取 AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(CarConfig.class); Car myCar = applicationContext.getBean(\u0026#34;myCar\u0026#34;, Car.class); System.out.println(myCar); } } 装配Bean最佳实践 装配Bean使用全注解 + 配置类的方式装配自定义Bean，是目前通用最优的方式了，因为SpringBoot用的就是这种方式。如果要修改SpringBoot的默认配置，也是通过配置文件或者JavaConfig的方式修改。比如通过数据源的案例\n数据源对象 1 2 3 4 5 6 7 @Data public class MySQLDataSource { private String driverName; private String url; private String username; private String password; } 创建配置类 配置类一般使用**@Configuration**注解描述，配置类通常用来配置系统信息或者诸如：数据库、消息队列、缓存等的第三方组件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Configuration public class MySQLDataSourceConfig { @Bean public MySQLDataSource dataSource() { System.out.println(\u0026#34;初始化数据库连接......\u0026#34;); MySQLDataSource dataSource = new MySQLDataSource(); dataSource.setDriverName(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;); dataSource.setUrl(\u0026#34;jdbc:mysql://localhost:3306/demo\u0026#34;); dataSource.setUsername(\u0026#34;root\u0026#34;); dataSource.setPassword(\u0026#34;123456\u0026#34;); return dataSource; } } 获取Bean对象 主类上使用**@ComponentScan**注解来配置要扫描的包，所有的类都应该放到此包下\n注意：@SpringBootApplication注解的启动类在启动时会扫描自己所在的包及其子包\n1 2 3 4 5 6 7 8 9 10 @SpringBootApplication //@ComponentScan(value = \u0026#34;top.lime\u0026#34;) //扫描top.lime包下的所有与@Component相关的注解 public class App { public static void main(String[] args) { //最优方案，使用包扫描，springboot启动时会扫描启动类所在包及其子包，如果不在启动类所在包则可用 AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(App.class); MySQLDataSource dataSource = applicationContext.getBean(MySQLDataSource.class); } } 小结 装配Bean时一般在一个主类上通过@ComponentScan设置包扫描 如果是第三方的配置通过配置类装载Bean，使用@Configuration注解描述类 配置文件 对于SpringBoot项目来说，很多配置项都是做了默认配置的，比如tomcat端口号，日志的输出规则，我们如果想要修改默认配置，要么自定义配置类覆盖原配置，要么在配置文件中修改参数，覆盖原配置。\nSpringBoot中的配置文件名字按照约定来说叫application.properties或者application.yml两种，放到resources目录下，这样项目启动时会自动读取，无需做其他配置，贴出两种配置文件，只是写法不同，推荐使用yml格式文件，是缩进类型的不需要写重复的公用前缀。\nproperties类型文件 1 2 3 4 # 设置端口号 server.port=8081 #设置编码 server.servlet.encoding.charset=UTF-8 yml类型文件 1 2 3 4 5 6 # yml文件是层级结构，比较简介，清晰 server: port: 8082 servlet: encoding: charset: UTF-8 读取配置文件 读取配置文件是开发中非常重要的操作，因为配置文件中通常会写重要的配置项，配置项在JavaConfig实现的配置类中往往会使用到，并不会在代码写死配置。\n通过@Value注解获取文件值 配置类中使用@Value注解获取配置文件内容，语法格式为\n@Value(\u0026quot;${配置文件中的key}\u0026quot;)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package com.stt.config; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Configuration; @Configuration public class ApplicationConfig { // 读取信息 @Value(\u0026#34;${spring.application.name}\u0026#34;) private String name; @Value(\u0026#34;${spring.application.version}\u0026#34;) private String version; @Value(\u0026#34;${spring.application.author}\u0026#34;) private String author; public void getInfo() { System.out.println(\u0026#34;name: \u0026#34; + name + \u0026#34;,version: \u0026#34; + version + \u0026#34;,author: \u0026#34; +author); } } 通过@ConfigurationProperties注解获取值 配置文件中新增person信息为例\n1 2 3 4 5 6 7 person: name: lime age: 18 id_card: 815811 hobby:\t# 列表、数组、集合 - fly - game 配置类内容如下，必须有set方法才可赋值成功：\n通过@Configuration注解表名是配置类，被Spring加载 通过@ConfigurationProperties(prefix = \u0026ldquo;person\u0026rdquo;)，指明前缀 属性名就写配置文件的后缀，如果有下划线，使用驼峰命名就可以了 类中不能有其他方法 1 2 3 4 5 6 7 8 9 10 @Data\t// lombok 生成get/set方法 @Configuration @ConfigurationProperties(prefix = \u0026#34;person\u0026#34;) public class PersonConfig { private String name; private Integer age; private String idCard; private List\u0026lt;String\u0026gt; hobby; } 读取自定义文件 我们上边读取的文件是springboot约定好的文件【application.yml/properties】，如果定义一个application-db.properties文件。这个文件不是SpringBoot约定好的，此时就需要指定文件读取\n1 2 3 4 db.classname= mysql db.url= localhost db.username= root db.password= 123456 读取properties文件 配置类中可以通过**@PropertySource**注解指定要读取的配置文件，可以指定多个\n1 2 3 4 5 6 7 8 9 10 @Configuration @PropertySource(value = {\u0026#34;application-db.properties\u0026#34;}) @ConfigurationProperties(prefix = \u0026#34;db\u0026#34;) @Data public class DBConfig { private String classname; private String url; private String username; private String password; } 读取yml文件 如果读取的是yml文件，则首先需要自定义一个资源工厂类，因为SpringBoot默认只实现了读取properties文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class YamlPropertySourceFactory extends DefaultPropertySourceFactory{ @Override public PropertySource\u0026lt;?\u0026gt; createPropertySource(String name, EncodedResource resource) throws IOException { Resource resourceResource = resource.getResource();//先得到资源文件 if(!resourceResource.exists()){ return new PropertiesPropertySource(null, new Properties()); } else if( //判断得到的资源文件是否是yml文件 resourceResource.getFilename().endsWith(\u0026#34;.yml\u0026#34;) || resourceResource.getFilename().endsWith(\u0026#34;.yaml\u0026#34;)){ System.out.println(\u0026#34;resourceResource = \u0026#34; + resourceResource.getFilename()); //开始加载yaml文件 List\u0026lt;PropertySource\u0026lt;?\u0026gt;\u0026gt; sources = new YamlPropertySourceLoader() .load(resourceResource.getFilename(),resourceResource); return sources.get(0); } return super.createPropertySource(name, resource); } } 接下来在@PropertySources注解上通过factory属性指定这个自定义的工厂\n1 2 3 4 5 6 7 8 9 10 @Configuration @PropertySources(value = {@PropertySource(value = {\u0026#34;application-db.yml\u0026#34;},factory = YamlPropertySourceFactory.class)}) @ConfigurationProperties(prefix = \u0026#34;db\u0026#34;) @Data public class DBConfig { private String classname; private String url; private String username; private String password; } 注意：@ImportResource注解用来加载xml文件，用SpringBoot就不需要xml文件了，这个注解基本不用\n通过Environment获取文件数据 还可以通过Spring提供的Environment对象获取文件数据，这个对象就霸道了。每一个文件中的值都可以获取到，用法相对较少，因为读取配置文件数据一般用在第三方组件的配置类中，配置类都是相互独立的，不会说读取所有数据，一般也是仅仅获取改配置类所需要的配置数据就可以\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @RestController public class UserController { @Autowired private Environment environment; public void controllerMethod() { System.out.println(\u0026#34;SttController=======》controllerMethod()\u0026#34;); } @GetMapping(\u0026#34;value\u0026#34;) public String getValue() { String username = environment.getProperty(\u0026#34;db.username\u0026#34;); String applicationName = environment.getProperty(\u0026#34;spring.application.name\u0026#34;); System.out.println(username); System.out.println(applicationName); return username + \u0026#34; : \u0026#34; + applicationName; } } profile 一般软件有开发环境、测试环境、生产环境，不同的环境有些配置可能不同，比如端口、回调地址、数据库地址、redis地址等，SpringBoot支持加载不同的配置文件，称之为profile。通常就是创建不同的配置文件，命名格式为application-${profile}.yml\n​\t默认只会加载application.yml文件不会加载其他文件。从日志也可以看出，下方红色框中的日志就表明没有激活任何profile，使用default 如果希望使用分环境加载，常见的方式有以下三种方式：\napplication.yml文件中通过spring.profiles.active配置 IDEA中配置参数，打包时不生效 启动jar命令添加\u0026ndash;spring.profiles.active配置 使用spring.profiles.active 指定dev环境\n1 2 3 spring: profiles: active: dev IDEA配置 首先点击编辑配置 选中项目，在有效配置文件选项中填入对应文件profile，点击应用和确定完成 如果同时存在则使用IDEA配置 通过命令注入参数 在启动jar时，通过java -jarxxx.jar \u0026ndash;spring.profiles.active=prod，命令追加参数，会使用注入参数的配置文件，这个参数是注入到虚拟机里边的哦！会覆盖配置文件中的spring.profiles.active的配置 依赖注入 Bean之间相互依赖可以通过依赖注入【Dependency Injection, DI】功能将一个Bean注入到另一个Bean中使用。例如Controller层调用Service层，Service层调用Dao层。\n简单的三层架构案例 下方列出核心代码，通过**@Autowired**注解注入对象。\nDao层 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 接口 public interface IUserDao { int insertUser(); } // 实现类 @Repository public class UserDaoImpl implements IUserDao { @Override public int insertUser() { System.out.println(\u0026#34;用户数据层添加用户\u0026#34;); return 0; } } Service层 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 接口 public interface IUserService { String createUser(); } // 实现类 @Service public class UserServiceImpl implements IUserService { @Autowired private IUserDao userDao; @Override public String createUser() { System.out.println(\u0026#34;用户服务层创建用户\u0026#34;); int result = userDao.insertUser(); return result \u0026gt; 0 ? \u0026#34;添加成功\u0026#34; : \u0026#34;添加失败\u0026#34;; } } controller层 1 2 3 4 5 6 7 8 9 10 11 12 13 @RestController @RequestMapping(\u0026#34;user\u0026#34;) public class UserController { @Autowired private IUserService userService; @RequestMapping(\u0026#34;create\u0026#34;) public String createUser() { System.out.println(\u0026#34;创建用户接口\u0026#34;); return userService.createUser(); } } 注入值的方式 Spring中注入值一般有三种方式：\n@Autowired：Spring提供的注解，默认根据type（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （接口的实现类），当一个接口存在多个实现类的话，byType这种方式就无法正确注入对象了，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个，这个时候，注入方式会变为 byName（根据名称进行匹配），这个名称通常就是类名（首字母小写）。另外，如果type无法辨别注入对象时，也可以配合@Qualifier或@Primary注解来分辨注入类。 @Resource：JavaEE提供的注解，默认根据name注入，如果不成功则按照type注入，name属性解析为bean的名称，type属性解析为bean的类型，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略，如果同时指定name 和type属性（不建议这么做）则注入方式为byType+byName。 构造方法：根据构造方法注入数据，原理与@Autowired相同，属性可以加final修饰，避免在业务中修改Bean的引用，增加安全性。 resource注解 1 2 @Resource private IUserService userService; 构造方法 1 2 3 4 5 private IUserService userService; public UserController(IUserService userService) { this.userService = userService; } setter方法 1 2 3 4 5 6 7 8 9 10 11 @RestController @RequestMapping(\u0026#34;user\u0026#34;) public class UserController { private IUserService userService; // 使用set方法注入 public void setUserService(IUserService userService) { this.userService = userService; } } 歧义性对象现象 当使用@Autowired注入时，编译期间IDEA就会提示，同时启动项目时，JVM报错，也是说存在两个Bean，构造方法的方式也会出现同样的错误。 注意：一般三层架构简引用不会存在一个接口实现多个实现类，但是当我们引入第三方组件，比如SpringSecurity、Druid等时一个组件可能会创建多个Bean，不同的功能会使用不同的Bean，就会出现这种问题。\n解决方案 使用**@Autowired**注解有两种方案：\n@Primary：在一个实现类上添加该注解，标明权重较高，当发现多个同类型Bean时优先使用被@Primary修饰的Bean。如果多个Bean都加了@Primary。那么IOC容器就又无法区分了 @Qualifier：使用在注入Bean的属性声明上，配置@Autowired实现根据类型和名字注入数据。 @Primary使用在实现类上\n1 2 3 4 @Service @Primary public class UserServiceImpl implements IUserService { } @Qualifier使用在数据注入上，先根据Type注入，再根据Name注入\n1 2 3 4 5 6 7 8 9 @RestController @RequestMapping(\u0026#34;user\u0026#34;) public class UserController { @Autowired @Qualifier(value = \u0026#34;userServiceImpl\u0026#34;) private IUserService userService; } 对于构造方法和set方法也是这样解决\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @RestController @RequestMapping(\u0026#34;user\u0026#34;) public class UserController { private IUserService userService; public UserController(@Autowired @Qualifier(value = \u0026#34;userServiceImpl\u0026#34;) IUserService userService) { this.userService = userService; } @RequestMapping(\u0026#34;create\u0026#34;) public String createUser() { System.out.println(\u0026#34;创建用户接口\u0026#34;); return userService.createUser(); } } setter方法\n1 2 3 4 5 @Autowired @Qualifier(\u0026#34;userServiceImpl\u0026#34;) public void setUserService(IUserService userService) { this.userService = userService; } 当使用@Resource注解注入数据时，会先根据name注入，再根据type注入，name值默认和属性名一致。如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 @RestController @RequestMapping(\u0026#34;user\u0026#34;) public class UserController { // name属性默认名为 userService。 @Resource private IUserService userService; @RequestMapping(\u0026#34;create\u0026#34;) public String createUser() { System.out.println(\u0026#34;创建用户接口\u0026#34;); return userService.createUser(); } } 属性名为userService那么就会默认去找beanName为userService的Bean，其实容器中没有，会再根据type注入，会找到两个对象，无法确定注入哪一个，就会出现以下错误：注入资源失败，没有合格的top.lime.service.IUserService类型bean\n解决方案就是根据name属性指明名字，或将属性名修改为正确的beanName\n1 2 3 4 5 6 7 @Resource(name = \u0026#34;userServiceImpl\u0026#34;) private IUserService userService; 或 @Resource private IUserService userServiceImpl; IDEA不建议使用Autowired 当使用Autowired注解时，IDEA中给出警告，不建议使用字段注入.\n但是使用@Resource注解时则没有警告提示。\n使用字段注入有一定风险存在：\n可能导致空指针异常：如果对象创建不使用Spring容器，而是直接使用无参构造方法new一个对象，此时使用注入的对象可能导致空指针异常。 不能使用final修饰字段：缺乏final修饰会使得类的依赖可变，进而可能引发一些不可预料的异常。通常情况下，可以使用构造方法注入来声明强制依赖的Bean，使用Setter方法注入来声明可选依赖的Bean。 可能更容易违反单一职责原则：这是一个关键原因。使用字段注入可能会轻易地在类中引入各种依赖，导致类的职责过多，但开发者往往难以察觉。相比之下，使用构造方法注入，当构造方法的参数过多时，会提示开发者重构这个类。 不利于写单元测试：在单元测试中，使用Field注入，必须使用反射的方式来Mock依赖对象。 推荐方案：\n当类有强依赖于其他Bean时，优先使用构造方法注入。 对于可选依赖，可以使用Setter方法注入，并在代码中处理可能出现的引用对象不存在的情况。 小结 依赖注入有两个注解、构造方法、setter方法三种方式，推荐使用构造方法方式注入bean，可以避免不必要的空指针异常，和Bean引用被修改的问题。\nBean作用域 在Spring容器中，Bean的作用域默认是单例的，可以通过@Scope注解设置，有6种作用域：\nprototype：一个bean定义可以有多个bean实例。 singleton：（默认的）在每个Spring IoC容器中，一个bean定义对应只会有唯一的一个bean实例。 request：一个bean定义对应于单个HTTP 请求的生命周期。也就是说，每个HTTP 请求都有一个bean实例，且该实例仅在这个HTTP 请求的生命周期里有效。该作用域仅适用于WebApplicationContext环境。 session：一个bean 定义对应于单个HTTP Session 的生命周期，也就是说，每个HTTP Session 都有一个bean实例，且该实例仅在这个HTTP Session 的生命周期里有效。该作用域仅适用于WebApplicationContext环境。 application：一个bean 定义对应于单个ServletContext 的生命周期。该作用域仅适用于WebApplicationContext环境。 websocket【这个作用范围没有找到在哪声明】：一个bean 定义对应于单个websocket 的生命周期。该作用域仅适用于WebApplicationContext环境。 1 2 3 4 5 6 7 8 9 10 @Repository // 声明作用范围 @Scope(value = \u0026#34;singleton\u0026#34;) public class UserDaoImpl implements IUserDao { @Override public int insertUser() { System.out.println(\u0026#34;用户数据层添加用户\u0026#34;); return 0; } } 条件装配 条件装配就是在满足相应条件的时候再装载对应的Bean，比如连接数据库时当数据源存在的时候再加载连接数据库的Bean，条件装配可以使用@Conditional和其派生注解实现。\n下方以数据库连接为例：\n数据源 1 2 3 4 5 6 7 8 9 @Data public class DataSource { private String driverClassName; private String url; private String username; private String password; } 数据库连接 数据库连接时需要用到数据数据源的参数数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Data public class DataCollectionService { private DataSource dataSource; public void collect() { String url = dataSource.getUrl(); String driverClassName = dataSource.getDriverClassName(); System.out.println(\u0026#34;连接数据库======》\u0026#34;); System.out.println(\u0026#34;url====》\u0026#34; + url); System.out.println(\u0026#34;driverClassName====》\u0026#34; + driverClassName); } } 配置类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Configuration public class ApplicationConfig { // 数据源配置 @Bean public DataSource dataSource() { DataSource dataSource = new DataSource(); dataSource.setDriverClassName(\u0026#34;com.mysql.jdbc.Driver\u0026#34;); dataSource.setUrl(\u0026#34;jdbc:mysql://localhost:3306/test\u0026#34;); dataSource.setUsername(\u0026#34;root\u0026#34;); dataSource.setPassword(\u0026#34;123456\u0026#34;); return dataSource; } // 连接配置 @Bean // 当DataSource这个bena存在时加载 @ConditionalOnBean(DataSource.class) public DataCollectionService dateCollectionService() { DataCollectionService dateCollectionService = new DataCollectionService(); System.out.println(\u0026#34;dataSource()====\u0026gt;\u0026#34; + dataSource()); dateCollectionService.setDataSource(dataSource()); return dateCollectionService; } } 测试类 1 2 3 4 5 6 7 8 9 @SpringBootApplication public class ConditionalApplication { public static void main(String[] args) { ConfigurableApplicationContext context = SpringApplication.run(ConditionalApplication.class); DataCollectionService dateCollectionService = (DataCollectionService) context.getBean(\u0026#34;dateCollectionService\u0026#34;); dateCollectionService.collect(); } } ——来自B站【石添的编程哲学】\n","date":"2024-11-12T22:28:47+08:00","permalink":"https://Canrea.github.io/p/spring-ioc%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/","title":"Spring IOC(控制反转)"},{"content":" maven-compiler-plugin插件 maven-compiler-plugin插件用于编译项目代码，其默认JDK版本可能不适用所有项目。通过配置插件的source和target属性，可以指定源码和目标编译的JDK版本，解决版本不匹配导致的编译问题。\nmaven-compiler-plugin插件的主要作用 指定JDK版本：Maven默认使用的JDK版本可能并不符合项目的实际需求，这样就容易出现版本不匹配，以至于可能导致编译不通过的问题。通过使用maven-compiler-plugin插件可以明确指定源代码所使用的JDK版本，以及编译后的类库运行的JVM版本，从而确保项目在不同环境中的一致性和稳定性。\n设置编码方式：源代码的编码方式对于编译和运行环境至关重要，maven-compiler-plugin插件允许设置代码和目标代码的编码方式，以防止因编码不一致导致的编译错误或乱码问题。\n优化编译过程：maven-compiler-plugin插件提供了丰富的配置选项，可以对编译过程进行细粒度的控制。例如，可以设置是否使用增量编译、是否生成调试信息等，以提高编译效率和代码质量。\n注意点 在配置maven-compiler-plugin插件时，需要注意以下几点：\n插件版本：确保使用的maven-compiler-plugin版本与Maven版本和JDK版本兼容，不同版本的插件可能具有不同的功能和配置选项。 JDK版本：根据项目实际需求选择合适的JDK版本，如果项目使用了较新的Java特性，需要确保JDK版本支持这些特性。 编码方式：确保源代码文件的编码方式与maven-compiler-plugin设置的编码方式一致，以避免编码问题导致的编译错误。 配置项 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;!-- 版本，要和jdk版本匹配 --\u0026gt; \u0026lt;version\u0026gt;3.8.1\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!-- 源码jdk版本 --\u0026gt; \u0026lt;source\u0026gt;1.8\u0026lt;/source\u0026gt; \u0026lt;!-- 目标jdk版本 --\u0026gt; \u0026lt;target\u0026gt;1.8\u0026lt;/target\u0026gt; \u0026lt;!-- 编码 --\u0026gt; \u0026lt;encoding\u0026gt;UTF-8\u0026lt;/encoding\u0026gt; \u0026lt;!-- 输出编译的详细细节，方便了解编译情况 --\u0026gt; \u0026lt;verbose\u0026gt;true\u0026lt;/verbose\u0026gt; \u0026lt;!-- 要使compilerVersion标签生效，还需要将fork设为true， 用于明确表示编译版本配置的可用。 fork和executable一般搭配使用，如果省略executable并设置true， maven编译器插件默认选择JAVA_HOME/bin/javac二进制文件， 如果设置了false，maven编译器插件将通过ToolProvider接口选择编译器。 这意味着不会启动新进程，Maven正在运行的JavaVM与会进行编译。 executable表示javac的绝对路径，默认会寻找环境变量JAVA_HOME的位置。 executable也可以自己设置一个路径。--\u0026gt; \u0026lt;fork\u0026gt;true\u0026lt;/fork\u0026gt; \u0026lt;!-- 设置外部jdk命令 --\u0026gt; \u0026lt;executable\u0026gt;${JAVA_HOME}/bin/javac\u0026lt;/executable\u0026gt; \u0026lt;!-- 最小内存 --\u0026gt; \u0026lt;meminitial\u0026gt;128m\u0026lt;/meminitial\u0026gt; \u0026lt;!-- 最大内存 --\u0026gt; \u0026lt;maxmem\u0026gt;512m\u0026lt;/maxmem\u0026gt; \u0026lt;!-- 设置编译时jdk的版本信息 --\u0026gt; \u0026lt;compilerVersion\u0026gt;1.8\u0026lt;/compilerVersion\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; spring-boot-maven-plugin插件 该插件是项目打包插件，可以配置打包的参数，不同参数会打出不同的jar/war包\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026lt;!--使用的插件列表 。 --\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!--plugin元素包含描述插件所需要的信息。 --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;!--插件在仓库里的group ID --\u0026gt; \u0026lt;groupId /\u0026gt; \u0026lt;!--插件在仓库里的artifact ID --\u0026gt; \u0026lt;artifactId /\u0026gt; \u0026lt;!--被使用的插件的版本（或版本范围） --\u0026gt; \u0026lt;version /\u0026gt; \u0026lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 --\u0026gt; \u0026lt;extensions /\u0026gt; \u0026lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;!--execution元素包含了插件执行需要的信息 --\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --\u0026gt; \u0026lt;id /\u0026gt; \u0026lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --\u0026gt; \u0026lt;phase /\u0026gt; \u0026lt;!--配置的执行目标 --\u0026gt; \u0026lt;goals /\u0026gt; \u0026lt;!--配置是否被传播到子POM --\u0026gt; \u0026lt;inherited /\u0026gt; \u0026lt;!--作为DOM对象的配置 --\u0026gt; \u0026lt;configuration /\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;!--项目引入插件所需要的额外依赖 --\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--参见dependencies/dependency元素 --\u0026gt; \u0026lt;dependency\u0026gt; ...... \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!--任何配置是否被传播到子项目 --\u0026gt; \u0026lt;inherited /\u0026gt; \u0026lt;!--作为DOM对象的配置 --\u0026gt; \u0026lt;configuration /\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; goals的可选值 build-image: 将程序使用 buildpack 打包进容器镜像中。\nbuild-info：生成项目的构建信息文件 build-info.properties。根据当前 MavenProject 的内容生成一个 - build-info.properties 文件\nhelp：显示帮助信息。调用mvn spring-boot:help -Ddetail=true -Dgoal=以显示参数详细信息。\nrepackage：可生成可执行的jar包或war包。插件的核心goal。 默认的 goal，将普通 mvn package 打包成的 jar 重新打包成包含所有程序依赖项的可执行 jar/war 文件，并保留 mvn package 打包的 jar 为 .original 后缀\nrun：运行 Spring Boot 应用\nstart：在集成测试阶段，控制生命周期。通常用于集成测试方案中，在 mvn integration-test 阶段管理 Spring Boot 应用的生命周期。\nstop：在集成测试阶段，控制生命周期。停止已通过 start 目标启动的应用程序。通常在 integration\u0026ndash; test 完成后调用。\n打包 将SpringBoot项目打包成Jar文件\n方法一 在idea右侧的Maven工具栏里面选择要打包的项目\u0026mdash;\u0026gt;点击Lifecycle\u0026mdash;\u0026gt;点击package。打包好的jar文件默认会生成在左侧项目列表的target里面。\n方法二 进入需要打包的项目主目录，在地址栏输入cmd，进入命令行控制台，在命令行执行以下代码。\n1 mvn clean package -Dmaven.test.skip=true 注意事项\njdk的环境变量需要配置好 maven的也要加入环境变量中 运行 1 Java -jar \u0026#34;jar包所在路径\u0026#34; ","date":"2024-11-12T13:19:11+08:00","permalink":"https://Canrea.github.io/p/springboot%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/","title":"SpringBoot项目打包"},{"content":" 通过Spring Initalizr创建 新建项目，选择Spring Initalizr（新版本显示 SpringBoot） 填写配置信息 Name : 项目名称\nLocation: 项目存放的位置\nLanguage: 开发语言\nType: 一般都选Maven进行依赖管理\nGroup: 所属组名\nArtifact: 项目名称\nPackage name: 包名\nJDK: JDK版本\nJava: 同上\nPackaging: 打包方式（springBoot应用一般都打成jar包）\n选择所需依赖 SpringBoot: 选择SpringBoot版本\n下面复选框: 选择所需的依赖\nCreate: 创建项目\n等待项目下载完成 启动项目 点击启动类左边的绿色三角型，或者右上角的绿色三角形，就能启动项目\n通过Maven创建SpringBoot项目 新建项目，选择maven 点击Create，创建项目，等待项目创建完成 修改pom.xml文件,点击右上角刷新按钮，下载依赖 给启动了加上@SpringBootApplication注解，并添加启动代码 启动成功 依赖管理 在父工程集中定义项目所需依赖的版本号\nspring-boot-dependencies 是Spring Boot提供的另一个重要的Maven项目，用于集中管理所有Spring Boot相关依赖的版本信息。\n特点 包含了Spring Boot中所有的starter依赖的版本信息，包括Spring Framework、Spring Boot自身以及其他常用的第三方库。 使用了部分来管理依赖的版本信息，但是不会直接引入依赖。 提供了一种简化依赖声明的方式，只需要声明spring-boot-starter-*相关的依赖，而无需指定版本号，因为版本号已经被spring-boot-dependencies管理了。 使用方法 在父工程的pom.xml中添加以下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;properties\u0026gt; \u0026lt;!-- 定义jdk版本 --\u0026gt; \u0026lt;java.version\u0026gt;8\u0026lt;/java.version\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;project.reporting.outputEncoding\u0026gt;UTF-8\u0026lt;/project.reporting.outputEncoding\u0026gt; \u0026lt;!-- 定义springboot版本 --\u0026gt; \u0026lt;spring-boot.version\u0026gt;3.0.2\u0026lt;/spring-boot.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- 引入阿里云的版本定义文件 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; ","date":"2024-11-11T18:29:39Z","permalink":"https://Canrea.github.io/p/%E5%88%9B%E5%BB%BAspringboot%E9%A1%B9%E7%9B%AE/","title":"创建SpringBoot项目"},{"content":"Hello world! ","date":"2024-11-02T18:29:39+08:00","image":"https://Canrea.github.io/p/hello_world/header_hu4927507090986297842.jpg","permalink":"https://Canrea.github.io/p/hello_world/","title":"Hello_World"}]