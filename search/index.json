[{"content":" IOC容器 Spring的IOC容器用来创建、存储、销毁对象并维护对象之间的关系，IOC容器也被称为【Bean容器】。\nIOC的概念 IOC全称【Inversion of Control】，意为控制反转，有的地方称为IOC容器，它是一项对象生成、获取和管理的技术，Java作为一门面向对象的语言，对象的管理至关重要。在传统的java编程中，对象一般通过new构建，二spring通过描述构建对象。\n项目中会有各式各样的对象，这些对象也不是独立存在互不相关的，spring提供了依赖注入【Dependency Injection，DI】来管理各个对象之间的关系。\n常见的关系有：依赖、关联、聚合、组合、继承、实现。\nIOC容器介绍 spring通过工厂创建对象，涉及到的接口和类非常多，其中我们经常打交道的有：\nBeanFactory：定义一系列获取bean的方法，根据不同参数，条件获取Bean，是整个IOC容器体系的根接口。 ApplicationContext：在BeanFactory基础上扩展了事件发布、资源加载、环境参数、国际化消息等功能。 ClassPathXmlApplicationContext：从类路径上读取spring声明文件来创建Bean。 FileSystemXmlApplicationContext：从文件中的spring声明文件来创建Bean。 AnnotationConfigApplicationContext：通过注解来创建Bean，需要指定要识别的包名，会识别通过诸如@Configuration、@Component、@Service、@Bean等描述的类。 ClassPathXmlApplicationContext实践 通过最原始的xml文件管理Bean，需要使用ClassPathXmlApplicationContext容器。\n数据源对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package top.lime.entity; public class User { private Long id; private String name; private Integer age; public User() { } public User(Long id, String name, Integer age) { this.id = id; this.name = name; this.age = age; } public Long getId() { return id; } public void setId(Long id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } @Override public String toString() { return \u0026#34;User{\u0026#34; + \u0026#34;id=\u0026#34; + id + \u0026#34;, name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, age=\u0026#34; + age + \u0026#39;}\u0026#39;; } } xml配置 在resources目录下创建springContext.xml配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;!-- spring描述Bean --\u0026gt; \u0026lt;!-- id属性是唯一的，不能重复 --\u0026gt; \u0026lt;bean id=\u0026#34;user1\u0026#34; class=\u0026#34;top.lime.entity.User\u0026#34;\u0026gt; \u0026lt;!-- 指定具体的属性数据 --\u0026gt; \u0026lt;!-- property是通过set方法注入的,需要实体类实现set方法 --\u0026gt; \u0026lt;property name=\u0026#34;id\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;zhangsan\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;age\u0026#34; value=\u0026#34;18\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;user2\u0026#34; class=\u0026#34;top.lime.entity.User\u0026#34;\u0026gt; \u0026lt;!-- 指定具体的属性数据 --\u0026gt; \u0026lt;!-- constructor-arg是通过构造方法注入的，需要实体类实现了构造方法 --\u0026gt; \u0026lt;constructor-arg name=\u0026#34;id\u0026#34; value=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;name\u0026#34; value=\u0026#34;lisi\u0026#34;/\u0026gt; \u0026lt;constructor-arg name=\u0026#34;age\u0026#34; value=\u0026#34;24\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt; 获取Bean对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @SpringBootApplication public class App { public static void main(String[] args) { //SpringApplication.run(App.class, args); //读取springContext.xml文件获取容器，并通过容器获取Bean ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(\u0026#34;springContext.xml\u0026#34;); //获取Bean，getBean()里面可以填Bean的id，也可填Bean的名字，对应xml里面Bean标签的id和name属性 //默认返回的是Object类型，可以强转回原来的类型 User user1 = (User) applicationContext.getBean(\u0026#34;user1\u0026#34;); //不想强转可以通过类型来获取Bean，如果有多个同类型的bean还要额外指定名字 User user2 = applicationContext.getBean(\u0026#34;user2\u0026#34;，User.class); //打印结果 System.out.println(user1); System.out.println(user2); } } FileSystemXmlApplicationContext实践 使用FileSystemXmlApplicationContext的话参数中填写文件路径，其余相同\n获取Bean对象 1 2 3 4 5 6 7 8 9 @SpringBootApplication public class App { public static void main(String[] args) { // 从文件系统获取,传入springContext.xml文件的路径，获取Bean FileSystemXmlApplicationContext applicationContext = new FileSystemXmlApplicationContext(\u0026#34;D:\\\\JavaWeb\\\\porject\\\\springContext.xml\u0026#34;); User user2 = applicationContext.getBean(\u0026#34;user2\u0026#34;, User.class); System.out.println(user2); } } AnnotationConfigApplicationContext实践 此处介绍两种创建Bean方式，一种是在AnnotationConfigApplicationContext的构造方法中传入包名，另一种是在构造方法中传入配置类。\n通过传入包名 在需要创建的Bean上通过@Component或者@Configuration等注解声明bean，相当于bean标签，通过@Value注解注入值。\n数据源对象 这里通过引入的lombok依赖，在类上加注解，实现在编译时生成get/set和构造方法的代码。\n1 2 3 4 5 6 7 8 9 10 11 12 @Data //生成get/set方法 @AllArgsConstructor //生成全参构造函数 @NoArgsConstructor //生成空参构造函数 @Component //通过注解创建对象，spring启动时扫描到有该注解的类，会当作一个Bean加载到IOC容器中 public class Book { @Value(\u0026#34;13\u0026#34;)\t//通过@Value注入参数 private Long id; @Value(\u0026#34;西游记\u0026#34;) private String bookName; @Value(\u0026#34;zhangsan\u0026#34;) private String author; } 获取Bean对象 1 2 3 4 5 6 7 8 9 10 11 12 public class App { public static void main(String[] args) { //通过注解获取Bean //通过包名扫描 比如：top.lime 就会扫描该包下所有的类和子包下的所有类 AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(\u0026#34;top.lime\u0026#34;); //获取Bean name默认的是首字母小写的类名 Book book1 = applicationContext.getBean(\u0026#34;book\u0026#34;); Book book2 = applicationContext.getBean(Book.class); System.out.println(book1); System.out.println(book2); } } 通过注解扫描包 在主类上添加@ComponentScan包扫描注解，注意：该注解会扫描述的类所在包和其子包的注解\n1 2 3 4 5 6 7 8 9 @ComponentScan(value = \u0026#34;top.lime\u0026#34;) //扫描top.lime包下的所有与@Component相关的注解 public class App { public static void main(String[] args) { //通过包扫描注解获取Bean AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(App.class); Book book = applicationContext.getBean(\u0026#34;book\u0026#34;, Book.class); System.out.println(book); } } 通过@Bean注解创建Bean 通过Bean注解创建对象的话，首先需要将User类中的@Value注解取消掉，否则Bean注入的值是Value注解注入的。\n数据源对象 1 2 3 4 5 6 @Data public class Car { private Long id; private String carName; private String brand; } 创建配置类 在配置类中生成Bean并注入IOC容器\n@Configuration：该注解使用在类上，标记该类为一个配置类，用@Component、@Service都可以，只是@Configuration注解更利于理解，更规范。目的就是项目启动时可以识别该类，并且加载该类到IOC容器中。因为该类中有Bean的创建，所以需要加载它！\n@Bean：该注解可以使用在方法和注解上，一般都使用在方法上，表示被描述的方法会返回一个Bean，方法内室创建这个Bean的过程，BeanName默认是方法名，可以通过Bean注解的value属性或name属性自定义BeanName\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //表示CarConfig是一个配置类,他是在@Component的基础上衍生出来的 @Configuration public class CarConfig { //创建Bean,Bean的名字默认是方法名 @Bean //如果需要指定名字则 @Bean(name=\u0026#34;car1\u0026#34;) public Car myCar() { Car car = new Car(); car.setId(10L); car.setCarName(\u0026#34;bird\u0026#34;); car.setBrand(\u0026#34;bbb\u0026#34;); //返回对象,交给IOC管理 return car; } } 获取Bean对象 1 2 3 4 5 6 7 8 public class App { public static void main(String[] args) { //通过@Bean注解创建Bean，并获取 AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(CarConfig.class); Car myCar = applicationContext.getBean(\u0026#34;myCar\u0026#34;, Car.class); System.out.println(myCar); } } 装配Bean最佳实践 装配Bean使用全注解 + 配置类的方式装配自定义Bean，是目前通用最优的方式了，因为SpringBoot用的就是这种方式。如果要修改SpringBoot的默认配置，也是通过配置文件或者JavaConfig的方式修改。比如通过数据源的案例\n数据源对象 1 2 3 4 5 6 7 @Data public class MySQLDataSource { private String driverName; private String url; private String username; private String password; } 创建配置类 配置类一般使用**@Configuration**注解描述，配置类通常用来配置系统信息或者诸如：数据库、消息队列、缓存等的第三方组件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Configuration public class MySQLDataSourceConfig { @Bean public MySQLDataSource dataSource() { System.out.println(\u0026#34;初始化数据库连接......\u0026#34;); MySQLDataSource dataSource = new MySQLDataSource(); dataSource.setDriverName(\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;); dataSource.setUrl(\u0026#34;jdbc:mysql://localhost:3306/demo\u0026#34;); dataSource.setUsername(\u0026#34;root\u0026#34;); dataSource.setPassword(\u0026#34;123456\u0026#34;); return dataSource; } } 获取Bean对象 主类上使用**@ComponentScan**注解来配置要扫描的包，所有的类都应该放到此包下\n注意：@SpringBootApplication注解的启动类在启动时会扫描自己所在的包及其子包\n1 2 3 4 5 6 7 8 9 10 @SpringBootApplication //@ComponentScan(value = \u0026#34;top.lime\u0026#34;) //扫描top.lime包下的所有与@Component相关的注解 public class App { public static void main(String[] args) { //最优方案，使用包扫描，springboot启动时会扫描启动类所在包及其子包，如果不在启动类所在包则可用 AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(App.class); MySQLDataSource dataSource = applicationContext.getBean(MySQLDataSource.class); } } 小结 装配Bean时一般在一个主类上通过@ComponentScan设置包扫描 如果是第三方的配置通过配置类装载Bean，使用@Configuration注解描述类 ","date":"2024-11-12T22:28:47+08:00","permalink":"https://Canrea.github.io/p/spring%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACioc/","title":"Spring控制反转IOC"},{"content":" maven-compiler-plugin插件 maven-compiler-plugin插件用于编译项目代码，其默认JDK版本可能不适用所有项目。通过配置插件的source和target属性，可以指定源码和目标编译的JDK版本，解决版本不匹配导致的编译问题。\nmaven-compiler-plugin插件的主要作用 指定JDK版本：Maven默认使用的JDK版本可能并不符合项目的实际需求，这样就容易出现版本不匹配，以至于可能导致编译不通过的问题。通过使用maven-compiler-plugin插件可以明确指定源代码所使用的JDK版本，以及编译后的类库运行的JVM版本，从而确保项目在不同环境中的一致性和稳定性。\n设置编码方式：源代码的编码方式对于编译和运行环境至关重要，maven-compiler-plugin插件允许设置代码和目标代码的编码方式，以防止因编码不一致导致的编译错误或乱码问题。\n优化编译过程：maven-compiler-plugin插件提供了丰富的配置选项，可以对编译过程进行细粒度的控制。例如，可以设置是否使用增量编译、是否生成调试信息等，以提高编译效率和代码质量。\n注意点 在配置maven-compiler-plugin插件时，需要注意以下几点：\n插件版本：确保使用的maven-compiler-plugin版本与Maven版本和JDK版本兼容，不同版本的插件可能具有不同的功能和配置选项。 JDK版本：根据项目实际需求选择合适的JDK版本，如果项目使用了较新的Java特性，需要确保JDK版本支持这些特性。 编码方式：确保源代码文件的编码方式与maven-compiler-plugin设置的编码方式一致，以避免编码问题导致的编译错误。 配置项 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;!-- 版本，要和jdk版本匹配 --\u0026gt; \u0026lt;version\u0026gt;3.8.1\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!-- 源码jdk版本 --\u0026gt; \u0026lt;source\u0026gt;1.8\u0026lt;/source\u0026gt; \u0026lt;!-- 目标jdk版本 --\u0026gt; \u0026lt;target\u0026gt;1.8\u0026lt;/target\u0026gt; \u0026lt;!-- 编码 --\u0026gt; \u0026lt;encoding\u0026gt;UTF-8\u0026lt;/encoding\u0026gt; \u0026lt;!-- 输出编译的详细细节，方便了解编译情况 --\u0026gt; \u0026lt;verbose\u0026gt;true\u0026lt;/verbose\u0026gt; \u0026lt;!-- 要使compilerVersion标签生效，还需要将fork设为true， 用于明确表示编译版本配置的可用。 fork和executable一般搭配使用，如果省略executable并设置true， maven编译器插件默认选择JAVA_HOME/bin/javac二进制文件， 如果设置了false，maven编译器插件将通过ToolProvider接口选择编译器。 这意味着不会启动新进程，Maven正在运行的JavaVM与会进行编译。 executable表示javac的绝对路径，默认会寻找环境变量JAVA_HOME的位置。 executable也可以自己设置一个路径。--\u0026gt; \u0026lt;fork\u0026gt;true\u0026lt;/fork\u0026gt; \u0026lt;!-- 设置外部jdk命令 --\u0026gt; \u0026lt;executable\u0026gt;${JAVA_HOME}/bin/javac\u0026lt;/executable\u0026gt; \u0026lt;!-- 最小内存 --\u0026gt; \u0026lt;meminitial\u0026gt;128m\u0026lt;/meminitial\u0026gt; \u0026lt;!-- 最大内存 --\u0026gt; \u0026lt;maxmem\u0026gt;512m\u0026lt;/maxmem\u0026gt; \u0026lt;!-- 设置编译时jdk的版本信息 --\u0026gt; \u0026lt;compilerVersion\u0026gt;1.8\u0026lt;/compilerVersion\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; spring-boot-maven-plugin插件 该插件是项目打包插件，可以配置打包的参数，不同参数会打出不同的jar/war包\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026lt;!--使用的插件列表 。 --\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!--plugin元素包含描述插件所需要的信息。 --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;!--插件在仓库里的group ID --\u0026gt; \u0026lt;groupId /\u0026gt; \u0026lt;!--插件在仓库里的artifact ID --\u0026gt; \u0026lt;artifactId /\u0026gt; \u0026lt;!--被使用的插件的版本（或版本范围） --\u0026gt; \u0026lt;version /\u0026gt; \u0026lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 --\u0026gt; \u0026lt;extensions /\u0026gt; \u0026lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;!--execution元素包含了插件执行需要的信息 --\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --\u0026gt; \u0026lt;id /\u0026gt; \u0026lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --\u0026gt; \u0026lt;phase /\u0026gt; \u0026lt;!--配置的执行目标 --\u0026gt; \u0026lt;goals /\u0026gt; \u0026lt;!--配置是否被传播到子POM --\u0026gt; \u0026lt;inherited /\u0026gt; \u0026lt;!--作为DOM对象的配置 --\u0026gt; \u0026lt;configuration /\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;!--项目引入插件所需要的额外依赖 --\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--参见dependencies/dependency元素 --\u0026gt; \u0026lt;dependency\u0026gt; ...... \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!--任何配置是否被传播到子项目 --\u0026gt; \u0026lt;inherited /\u0026gt; \u0026lt;!--作为DOM对象的配置 --\u0026gt; \u0026lt;configuration /\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; goals的可选值 build-image: 将程序使用 buildpack 打包进容器镜像中。\nbuild-info：生成项目的构建信息文件 build-info.properties。根据当前 MavenProject 的内容生成一个 - build-info.properties 文件\nhelp：显示帮助信息。调用mvn spring-boot:help -Ddetail=true -Dgoal=以显示参数详细信息。\nrepackage：可生成可执行的jar包或war包。插件的核心goal。 默认的 goal，将普通 mvn package 打包成的 jar 重新打包成包含所有程序依赖项的可执行 jar/war 文件，并保留 mvn package 打包的 jar 为 .original 后缀\nrun：运行 Spring Boot 应用\nstart：在集成测试阶段，控制生命周期。通常用于集成测试方案中，在 mvn integration-test 阶段管理 Spring Boot 应用的生命周期。\nstop：在集成测试阶段，控制生命周期。停止已通过 start 目标启动的应用程序。通常在 integration\u0026ndash; test 完成后调用。\n打包 将SpringBoot项目打包成Jar文件\n方法一 在idea右侧的Maven工具栏里面选择要打包的项目\u0026mdash;\u0026gt;点击Lifecycle\u0026mdash;\u0026gt;点击package。打包好的jar文件默认会生成在左侧项目列表的target里面。\n方法二 进入需要打包的项目主目录，在地址栏输入cmd，进入命令行控制台，在命令行执行以下代码。\n1 mvn clean package -Dmaven.test.skip=true 注意事项\njdk的环境变量需要配置好 maven的也要加入环境变量中 运行 1 Java -jar \u0026#34;jar包所在路径\u0026#34; ","date":"2024-11-12T13:19:11+08:00","permalink":"https://Canrea.github.io/p/springboot%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85/","title":"SpringBoot项目打包"},{"content":" 通过Spring Initalizr创建 新建项目，选择Spring Initalizr（新版本显示 SpringBoot） 填写配置信息 Name : 项目名称\nLocation: 项目存放的位置\nLanguage: 开发语言\nType: 一般都选Maven进行依赖管理\nGroup: 所属组名\nArtifact: 项目名称\nPackage name: 包名\nJDK: JDK版本\nJava: 同上\nPackaging: 打包方式（springBoot应用一般都打成jar包）\n选择所需依赖 SpringBoot: 选择SpringBoot版本\n下面复选框: 选择所需的依赖\nCreate: 创建项目\n等待项目下载完成 启动项目 点击启动类左边的绿色三角型，或者右上角的绿色三角形，就能启动项目\n通过Maven创建SpringBoot项目 新建项目，选择maven 点击Create，创建项目，等待项目创建完成 修改pom.xml文件,点击右上角刷新按钮，下载依赖 给启动了加上@SpringBootApplication注解，并添加启动代码 启动成功 依赖管理 在父工程集中定义项目所需依赖的版本号\nspring-boot-dependencies 是Spring Boot提供的另一个重要的Maven项目，用于集中管理所有Spring Boot相关依赖的版本信息。\n特点 包含了Spring Boot中所有的starter依赖的版本信息，包括Spring Framework、Spring Boot自身以及其他常用的第三方库。 使用了部分来管理依赖的版本信息，但是不会直接引入依赖。 提供了一种简化依赖声明的方式，只需要声明spring-boot-starter-*相关的依赖，而无需指定版本号，因为版本号已经被spring-boot-dependencies管理了。 使用方法 在父工程的pom.xml中添加以下代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;properties\u0026gt; \u0026lt;!-- 定义jdk版本 --\u0026gt; \u0026lt;java.version\u0026gt;8\u0026lt;/java.version\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;project.reporting.outputEncoding\u0026gt;UTF-8\u0026lt;/project.reporting.outputEncoding\u0026gt; \u0026lt;!-- 定义springboot版本 --\u0026gt; \u0026lt;spring-boot.version\u0026gt;3.0.2\u0026lt;/spring-boot.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- 引入阿里云的版本定义文件 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; ","date":"2024-11-11T18:29:39Z","permalink":"https://Canrea.github.io/p/%E5%88%9B%E5%BB%BAspringboot%E9%A1%B9%E7%9B%AE/","title":"创建SpringBoot项目"},{"content":"Hello world! ","date":"2024-11-02T18:29:39+08:00","image":"https://Canrea.github.io/p/hello_world/header_hu4927507090986297842.jpg","permalink":"https://Canrea.github.io/p/hello_world/","title":"Hello_World"}]